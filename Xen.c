#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl9,  AutonExtra,     sensorDigitalIn)
#pragma config(Sensor, dgtl10, Testing,        sensorDigitalIn)
#pragma config(Sensor, dgtl11, AutonLeft,      sensorDigitalIn)
#pragma config(Sensor, dgtl12, AutonRight,     sensorDigitalIn)
#pragma config(Sensor, I2C_1,  backLeft,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  backRight,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  frontRight,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  frontLeft,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393TurboSpeed_MC29, openLoop, driveLeft, encoderPort, I2C_4)
#pragma config(Motor,  port3,           backLeft,      tmotorVex393TurboSpeed_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port4,           backRight,     tmotorVex393TurboSpeed_MC29, openLoop, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393TurboSpeed_MC29, openLoop, driveRight, encoderPort, I2C_3)
#pragma config(Motor,  port6,           LiftY,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightLiftY,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftLiftY,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Drive base on 2-5
Left and Right Lift on Power Expander
Claw and LiftY on cortex 6-9
*/

// This code is for the VEX cortex platform.
#pragma platform(VEX2)
// Select Download method as "competition".
#pragma competitionControl(Competition)
// Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ERHS Robotics Team 2016-2017 Robot 4100C Code (Xen). --Aidan Artherton  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*--------------------------"Settings" and Info Code Start-------------------------*/

int fError, bError, rError, lError, lDiagError, rDiagError;
int FR, BR, FL, BL;

void Velocity(byte motorValue, byte maxVelocity, byte ifNegate = 1, static float scaleFactor = 0.01) {
	/*--------------------------------------------------------------------------*/
	/* We want to find the error of every motor against each other, so we 			*/
	/* subtract the sides so we can add or subtract to the motor depending on		*/
	/* which side it's on.                                                      */
	/*--------------------------------------------------------------------------*/
	fError = abs(nMotorEncoder[frontRight]) - abs(nMotorEncoder[frontLeft]);
	bError = abs(nMotorEncoder[backRight]) - abs(nMotorEncoder[backLeft]);
	rError = abs(nMotorEncoder[frontRight]) - abs(nMotorEncoder[backRight]);
	lError = abs(nMotorEncoder[frontLeft]) - abs(nMotorEncoder[backLeft]);
	lDiagError = abs(nMotorEncoder[frontLeft]) - abs(nMotorEncoder[backRight]);
	rDiagError = abs(nMotorEncoder[frontRight]) - abs(nMotorEncoder[backLeft]);

	/*--------------------------------------------------------------------------*/
	/* Set motor value to intended motor value plus the error correction. 			*/
	/* Divided by six because, you want to take the average of the three 				*/
	/* values, which would be divided by three, and then you would want to 			*/
	/* divide by two becasue you wouldn't want to add and subtract the values   */
	/* from each side or it would overcorrect.                      						*/
	/*--------------------------------------------------------------------------*/
	BL = motorValue + (scaleFactor * ((lError + bError + rDiagError) / 6));
	BR = motorValue + (scaleFactor * ((rError - bError + lDiagError) / 6));
	FL = motorValue + (scaleFactor * ((-lError + fError - lDiagError) / 6));
	FR = motorValue + (scaleFactor * ((-rError - fError - rDiagError)  / 6));

	// Set the motor value to the maxVelocity if it is above the max velocity, or to the original value if it isn't.
	motor[backLeft] = BL > maxVelocity ? maxVelocity : BL;
	motor[backRight] = ifNegate * BR < maxVelocity ? ifNegate * maxVelocity : ifNegate * BR;
	motor[frontLeft] = FL > maxVelocity ? maxVelocity : FL;
	motor[frontRight] = ifNegate * FR < maxVelocity ? ifNegate * maxVelocity : ifNegate * FR;
}

void TDrive(byte leftDriveS, byte rightDriveS, int driveTime) {
	startMotor(backLeft, leftDriveS);
	startMotor(frontLeft, leftDriveS);
	startMotor(backRight, -rightDriveS);
	startMotor(frontRight, -rightDriveS);
	delay(driveTime);
	stopMotor(backLeft);
	stopMotor(frontLeft);
	stopMotor(backRight);
	stopMotor(backLeft);
}

void Drive(byte motorValue, byte maxVelocity, int driveTime = 0, byte ifNegate = 1, static float scaleFactor = 0.01) {
	/*--------------------------------------------------------------------------*/
	/* We want to find the error of every motor against each other, so we 			*/
	/* subtract the sides so we can add or subtract to the motor depending on		*/
	/* which side it's on.                                                      */
	/*--------------------------------------------------------------------------*/
	clearTimer(T1);
	while(time1[T1] <= driveTime) {
		fError = abs(nMotorEncoder[frontRight]) - abs(nMotorEncoder[frontLeft]);
		bError = abs(nMotorEncoder[backRight]) - abs(nMotorEncoder[backLeft]);
		rError = abs(nMotorEncoder[frontRight]) - abs(nMotorEncoder[backRight]);
		lError = abs(nMotorEncoder[frontLeft]) - abs(nMotorEncoder[backLeft]);
		lDiagError = abs(nMotorEncoder[frontLeft]) - abs(nMotorEncoder[backRight]);
		rDiagError = abs(nMotorEncoder[frontRight]) - abs(nMotorEncoder[backLeft]);

		/*--------------------------------------------------------------------------*/
		/* Set motor value to intended motor value plus the error correction. 			*/
		/* Divided by six because, you want to take the average of the three 				*/
		/* values, which would be divided by three, and then you would want to 			*/
		/* divide by two becasue you wouldn't want to add and subtract the values   */
		/* from each side or it would overcorrect.                      						*/
		/*--------------------------------------------------------------------------*/
		BL = motorValue + (scaleFactor * ((lError + bError + rDiagError) / 6));
		BR = motorValue + (scaleFactor * ((rError - bError + lDiagError) / 6));
		FL = motorValue + (scaleFactor * ((-lError + fError - lDiagError) / 6));
		FR = motorValue + (scaleFactor * ((-rError - fError - rDiagError)  / 6));

		// Set the motor value to the maxVelocity if it is above the max velocity, or to the original value if it isn't.
		motor[backLeft] = BL > maxVelocity ? maxVelocity : BL;
		motor[backRight] = ifNegate * BR < maxVelocity ? ifNegate * maxVelocity : ifNegate * BR;
		motor[frontLeft] = FL > maxVelocity ? maxVelocity : FL;
		motor[frontRight] = ifNegate * FR < maxVelocity ? ifNegate * maxVelocity : ifNegate * FR;
		delay(35);
	}
	motor[backLeft] = motor[backRight] = motor[frontLeft] = motor[frontRight] = 0;
}

void Lift(byte Lift) {
	motor[LiftY] = Lift;
	motor[rightLiftY] = Lift;
	motor[leftLiftY] = Lift;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*													LED References for IME's												*/
/*																																					*/
/* Yellow - Not Initialized (default Address)																*/
/*																																					*/
/* Every 3 sec																															*/
/* Green Blink - initialized, valid I2C communications, in neutral					*/
/* Green Double Blink - initialized, valid I2C communications, in neutral		*/
/* and terminated																														*/
/*																																					*/
/* Blinking Green - relative to speed																				*/
/* Solid Green - full speed in either direction															*/
/*																																					*/
/* Yellow (same as Green patterns) - counter overflow												*/
/*																																					*/
/* Solid Red - data is being written to EEPROM (1sec)												*/
/* Blinking Red - address range error (a valid address will clear error)		*/
/*																																					*/
/* Green Blip - I2C communications lost, initialized and in neutral					*/
/* Green Double Blip - I2C communications lost, initialized, neutral and `	*/
/* terminated                                    														*/
/*--------------------------------------------------------------------------*/


/*----------------------------------PID Code Start---------------------------------*/
/*-----------------------------------------------------------------------------------*/
/* This will be an example of my PID code with detailed explanation and instruction. */
/*-----------------------------------------------------------------------------------*/

/*---------------------------------------------------*/
/*																									 */
/*			Ticks/revolution of motor configurations		 */
/*																									 */
/* High Torque measures 627.2 ticks per revolution	 */
/* High Speed measures 392 ticks per revolution			 */
/* Turbo Speed measures 261.333 ticks per revolution */
/*---------------------------------------------------*/

/*---------------------------------------------------------------------------------*/
/* First, we must make a function to convert inches into ticks. A little math is	 */
/* required to do this. You may follow this guide to create your function based	 	 */
/* upon your needs. The chart above will tell you the ticks/revolution of your 		 */
/* respective gear ratio.																													 */
/*																																								 */
/* To create a function that converts inches to ticks, we have to make some				 */
/* calculations. We must consider the size of the wheel(s) being used and the			 */
/* Ticks/Revolution of your gear ratio. I will be using 4" Omni-Wheels and Turbo.	 */
/* Each side has two wheels so we can say that "1 turn = 261.333 ticks". The  */
/* distance each wheel moves in one turn is "4*pi inches" (pi*diameter). So, that	 */
/* means that "4 * pi inches = 261.333 ticks". This equates to 83.18498				 */
/* ticks/inch. You can create a function using this calculation, called 				   */
/* inchesToTicks.																																	 */
/*---------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------*/
/* Turbo = 83.18498 ticks/inch																										 */
/* High Speed = 124.77748 ticks/inch																							 */
/* High Torque = 199.64396 ticks/inch 																						 */
/*---------------------------------------------------------------------------------*/

static float TURBO_TICKS_TO_INCH = 20.7962459;
static float HIGH_SPEED_TICKS_TO_INCH = 31.1943688;
static float HIGH_TORQUE_TICKS_TO_INCH = 49.9109902;

float inchesToTicks(float inches) {
	return inches * TURBO_TICKS_TO_INCH;
}

float ticksToInches(float ticks) {
	return ticks / TURBO_TICKS_TO_INCH;
}

float degreesToTicks(float degrees) {
	int ticksPerTurn = 1500;
	return degrees * ticksPerTurn / 360;
}

void zeroMotorEncoders() {
	nMotorEncoder[backLeft] = nMotorEncoder[backRight] = nMotorEncoder[frontLeft] = nMotorEncoder[frontRight] = 0;
}

float sumMotorEncoders() {
	return(abs(nMotorEncoder[backLeft]) + abs(nMotorEncoder[backRight]) + abs(nMotorEncoder[frontLeft]) + abs(nMotorEncoder[frontRight]));
}

void PDrive(int target) {
	zeroMotorEncoders();
	//target = ((2 * target) / 3);
	static int velocity = 30;
	static int minSpeed = 24;
	static int maxSpeed = 100;
	float speed = (target * maxSpeed) / velocity;

	writeDebugStream("speed: %d, target: %d, maxSpeed: %d, velocity: %d\n", speed, target, maxSpeed, velocity);

	speed = speed > maxSpeed ? maxSpeed : speed;
	speed = speed < -maxSpeed ? -maxSpeed : speed;

	float distance = inchesToTicks(abs(target));
	float error = distance;
	float P;
	writeDebugStream("Loop Start:");

	while(error > 30) {
		error = distance - ((sumMotorEncoders())/4);

		P = -((((ticksToInches(error)/ticksToInches(distance)) - (ticksToInches(distance) / 2))) * (((ticksToInches(error)/ticksToInches(distance)) - (ticksToInches(distance) / 2)))) + ((ticksToInches(distance) * ticksToInches(distance)) / 4) + minSpeed;

		if(error < distance/2 && P <= minSpeed) {
			P = 0;
		}

		Velocity(P, speed);

		writeDebugStream("P: %d, speed: %d, error: %d\n", P, speed, error);
		delay(35);
	}
	motor[backLeft] = motor[backRight] = motor[frontLeft] = motor[frontRight] = 0;
	writeDebugStream("FL: %d, BL: %d, BR: %d, FR: %d\n", nMotorEncoder[frontLeft], nMotorEncoder[backLeft], nMotorEncoder[backRight], nMotorEncoder[frontRight]);
}

void PTurn(int target) {
	zeroMotorEncoders();
	static int velocity = 30;
	static int minSpeed = 24;
	static int maxSpeed = 100;
	float speed = (target * maxSpeed) / velocity;

	writeDebugStream("speed: %d, target: %d, maxSpeed: %d, velocity: %d\n", speed, target, maxSpeed, velocity);

	speed = speed > maxSpeed ? maxSpeed : speed;
	speed = speed < -maxSpeed ? -maxSpeed : speed;

	float distance = inchesToTicks(abs(target));
	float error = distance;
	int slopeNegate;
	float P;
	writeDebugStream("Loop Start:");

	while(error > 30) {
		error = distance - ((sumMotorEncoders())/4);

		P = -((((ticksToInches(error)/ticksToInches(distance)) - (ticksToInches(distance) / 2))) * (((ticksToInches(error)/ticksToInches(distance)) - (ticksToInches(distance) / 2)))) + ((ticksToInches(distance) * ticksToInches(distance)) / 4) + minSpeed;

		if(error < distance/2 && P <= minSpeed) {
			P = 0;
		}

		Velocity(P, speed);

		writeDebugStream("P: %d, speed: %d, error: %d\n", P, speed, error);
		delay(35);
	}
	motor[backLeft] = motor[backRight] = motor[frontLeft] = motor[frontRight] = 0;
	writeDebugStream("FL: %d, BL: %d, BR: %d, FR: %d\n", nMotorEncoder[frontLeft], nMotorEncoder[backLeft], nMotorEncoder[backRight], nMotorEncoder[frontRight]);
}

void testVelocity() {
	zeroMotorEncoders();
	clearTimer(T1);
	motor[backLeft] = motor[backRight] = motor[frontLeft] = motor[frontRight] = 100;
	while(time1[T1] <= 1000) {
		if(time1[T1] == 1000) {
			motor[backLeft] = motor[backRight] = motor[frontLeft] = motor[frontRight] = 0;
		}
	}
	float tickDistance = sumMotorEncoders();
	float distance = tickDistance / TURBO_TICKS_TO_INCH;
	writeDebugStream("Velicity: %d", distance);
}
/*---------------------------"Settings" and Info Code End--------------------------*/

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous() {
	// ..........................................................................
	if(SensorValue(AutonRight) == 0) {
		// Get claw off wheels
		motor[claw] = -127;
		delay(250);
		motor[claw] = 0;
		// Lift so opening claw doesn't hit fence.
		Lift(127);
		delay(800);
		Lift(0);
		// Close claw and bring Lift back down when it gets out of the way of the fence. (MAY NEED TO TUNE HOW FAR OPEN THE CLAW IS FOR THE STARS)
		motor[claw] = -127;
		delay(500);
		Lift(0);
		delay(750);
		motor[claw] = 0;
		Lift(-127);
		delay(1000);
		Lift(0);
		// Drive into stars to other square. TEMP
		Drive(127, 127, 1850);
		delay(250);
		// Close claw on stars (MAY NEED TO CONTINUE CLOSING WHILE DRIVING).
		motor[claw] = -127;
		delay(1000);
		motor[claw] = 0;
		// Turn 90 degrees to the right to face towards fence.
		TDrive(-127, -127, 500);
		// Drive enough to allow for a 180 turn.
		Drive(127, 127, 1100);
		// Turn 180 degrees to throw over.
		TDrive(127, 127, 1000);
		// Start to throw over.
		Lift(127);
		// Drive the rest of the way to fence while throwing.
		Drive(127, 127, 1100);
		delay(300);
		Lift(0);
		// We lit?
	}

	if(SensorValue(AutonLeft) == 0) {
		// What we did after school (IF PID DOESNT WORK REPLACE THE PTURN, IF IT DOES REPLACE THE DRIVE FUNCTIONS):
		// Get claw off wheels
		motor[claw] = -127;
		delay(250);
		motor[claw] = 0;
		// Lift so opening claw doesn't hit fence.
		Lift(127);
		delay(800);
		Lift(0);
		// Close claw and bring Lift back down when it gets out of the way of the fence. (MAY NEED TO TUNE HOW FAR OPEN THE CLAW IS FOR THE STARS)
		motor[claw] = -127;
		delay(500);
		Lift(0);
		delay(750);
		motor[claw] = 0;
		Lift(-127);
		delay(1000);
		Lift(0);
		// Drive into stars to other square. TEMP
		Drive(127, 127, 1850);
		delay(250);
		// Close claw on stars (MAY NEED TO CONTINUE CLOSING WHILE DRIVING).
		motor[claw] = -127;
		delay(1000);
		motor[claw] = 0;
		// Turn 90 degrees to the right to face towards fence.
		TDrive(-127, -127, 500);
		// Drive enough to allow for a 180 turn.
		Drive(127, 127, 1100);
		// Turn 180 degrees to throw over.
		TDrive(127, 127, 1000);
		// Start to throw over.
		Lift(127);
		// Drive the rest of the way to fence while throwing.
		Drive(127, 127, 1100);
		delay(300);
		Lift(0);
		// We lit?
	}

	if(SensorValue(Testing) == 0) {
		motor[claw] = -127;
		delay(1000);
		motor[claw] = 0;
		Drive(127, 127, 900);
		Lift(100);
		Drive(127, 127, 700);
		Lift(0);
	}

	if(SensorValue(AutonExtra) == 0) {
		// Cube Auton
		// Get claw off wheels
		motor[claw] = -127;
		delay(250);
		motor[claw] = 0;
		// Drive to Cube.
		Drive(127, 127, 1000);
		// Close claw on cube.
		motor[claw] = -127;
		delay(1600);
		// Lift cube a little so it doesn't drag.
		Lift(45);
		delay(500);
		// Turn to fence.
		TDrive(127, 127, 700);
		motor[claw] = 0;
		// Drive to fence.
		Drive(-127, -127, 1300);
		// Throw cube over fence.
		Lift(127);
		delay(1300);
		motor[claw] = 127;
		Lift(0);
		delay(500);
		motor[claw] = 0;
		// Bring lift back down to get stars.
		Drive(-127, -127, 300);
		Lift(-127);
		delay(300);
		motor[claw] = 127;
		Drive(127, 127, 600);
		motor[claw] = 0;
		Drive(127, 127, 500);
		Lift(0);
		// Drive to stars.
		Drive(127, 127, 1300);
		// Close claw on stars.
		motor[claw] = -127;
		delay(1800);
		motor[claw] = -85;
		// Drive to fence.
		Drive(-127, -127, 1600);
		// Throw cube over fence.
		Lift(127);
		delay(1400);
		motor[claw] = 127;
		delay(300);
		Lift(0);
		delay(500);
		motor[claw] = -127;
		delay(200);
		// Bring lift back down for competition.
		Drive(-127, -127, 300);
		motor[claw] = 0;
		Lift(-127);
		delay(300);
		motor[claw] = 127;
		Drive(127, 127, 500);
		Lift(0);
		delay(200);
		motor[claw] = 0;
		//We lit.
	}
	// ..........................................................................

	// Remove this function call once you have "real" code.
	//AutonomousCodePlaceholderForTesting();
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol() {
	// User control code here, inside the loop
	static byte threshold = 10;
	static float forceFactor = 0.7071068;
	while(true) {
		motor[backLeft] = (abs(vexRT[Ch3]) > threshold ? vexRT[Ch3] : 0);
		motor[frontLeft] = (abs(vexRT[Ch3]) > threshold ? vexRT[Ch3] : 0) * forceFactor;
		motor[frontRight] = (abs(vexRT[Ch2]) > threshold ? vexRT[Ch2] : 0) * forceFactor;
		motor[backRight] = (abs(vexRT[Ch2]) > threshold ? vexRT[Ch2] : 0);

		if(vexRT[Btn6U] == 1) {
			Lift(127);
		}
		else if(vexRT[Btn6D] == 1) {
			Lift(-100);
		}
		else {
			Lift(0);
		}

		if(vexRT[Btn5U] == 1) {
			motor[claw] = -127;
		}
		else if(vexRT[Btn5D] == 1) {
			motor[claw] = 127;
		}
		else {
			motor[claw] = 0;
		}
	}
	// ........................................................................

	// Remove this function call once you have "real" code.
	//UserControlCodePlaceholderForTesting();
}
